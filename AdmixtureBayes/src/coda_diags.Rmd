---
title: "R analysis using coda"
output: html_notebook
---

Read in data

```{r}
df=read.csv('result_mc3.csv', header=T)
df=df[2:nrow(df),]
#sim_df=read.csv('sim_prior2.csv', header =T)
summs_df=read.csv('summaries.csv', header = T)
summaries_in_dataframe=sapply(summs_df$summary, function(x){ return(x%in%colnames(df)) })
summs_df=summs_df[summaries_in_dataframe,]
library('coda')
```

Making a function for calculating every statistics within a dataframe

```{r}
all_nums=function(df){
  mcmcobj=mcmc(df)
  res_df=data.frame(summary=colnames(df))
  summ_object=summary(mcmcobj)
  res_df$mean=summ_object[[1]][,1]
  res_df$naive_se=summ_object[[1]][,3]
  res_df$se=summ_object[[1]][,4]
  res_df$lower=summ_object[[2]][,1]
  res_df$median=summ_object[[2]][,3]
  res_df$upper=summ_object[[2]][,5]
  res_df$geweke_pval=2*pnorm(-abs(geweke.diag(mcmcobj)$z))
  res_df$rejection=rejectionRate(mcmcobj)
  res_df$ESS=effectiveSize(mcmcobj)
  return(res_df)
}

all_plots=function(df){
  mcmcobj=mcmc(df)
  crosscorr.plot(mcmcobj)
  for(v in colnames(df)){
    df2=as.data.frame(df[,v])
    #print(df2)
    colnames(df2) <- c(v)
    mcmcobj=mcmc(df2)
    plot(mcmcobj)
    autocorr.plot(mcmcobj)
    #cumuplot(mcmcobj)
  }
}

SE_per_category=function(x,breaks){
  list_indicators <- list()
  for(i in 1:(length(breaks)-1)){
    list_indicators[[i]] <- (x<breaks[i+1])*(x>=breaks[i])
  }
  df_parted=data.frame(list_indicators)
  colnames(df_parted) <- as.character(0:(length(list_indicators)-1))
  mcmcobj=mcmc(df_parted)
  summ_object=summary(mcmcobj)
  return(summ_object[[1]][,4])
}

hist_numbers=function(x, true, name='x'){
  fd=hist(c(x,true), plot=F, breaks=20)
  breaks=fd$breaks
  if(min(breaks)<0.01 & min(breaks)>-0.01){
    breaks=0:(floor(max(breaks))+2)-0.5
  }
  ad=hist(x, col=rgb(1,0,0,0.5), breaks=breaks, freq=F, ylim=c(0,max(fd$density)*1.5), main=name)
  bd=hist(true, breaks=breaks, add=TRUE, col=rgb(0,1,0,0.5), freq=F)
  ESS=effectiveSize(mcmc(x))
  obs_p=(ad$count/length(x))
  true_p=(bd$count/length(true))
  obs_p_censored=(ad$count/length(x))[bd$counts>0]
  true_p_censored=(bd$count/length(true))[bd$counts>0]
  se=rep(0, length(breaks))#SE_per_category(x,breaks)
  #print(se)
  for(i in 1:length(obs_p)){
    lines(rep(ad$mids[i],2)  ,  1/(breaks[2]-breaks[1])*sapply(obs_p[i]+c(-1,1)*2*se[i], function(x) max(x,0)), lw=2.4)
  }
  #print('made lines')
  G=ESS*sum((obs_p_censored-true_p_censored)^2/true_p_censored)
  return(list(chisquare_test=data.frame(G=G, pobs_ESS=1-pchisq(G, length(obs_p_censored)-1), pobs_N=1-pchisq(G*length(x)/ESS, length(obs_p_censored)-1)),
              pvals=2*pnorm(-abs(obs_p-true_p)/se)))
}

hist_numbers2=function(x, true_val, name='x'){
  fd=hist(c(x,true_val), plot=F, breaks=20)
  breaks=fd$breaks
  if(min(breaks)<0.01 & min(breaks)>-0.01){
    breaks=0:(floor(max(breaks))+2)-0.5
  }
  ad=hist(x, col=rgb(1,0,0,0.5), breaks=breaks, freq=F, ylim=c(0,max(fd$density)*1.5), main=name)
  abline(v=true_val, lwd=2)
  ESS=effectiveSize(mcmc(x))
  obs_p=(ad$count/length(x))
  se=SE_per_category(x,breaks)
  #print(se)
  for(i in 1:length(obs_p)){
    lines(rep(ad$mids[i],2)  ,  1/(breaks[2]-breaks[1])*sapply(obs_p[i]+c(-1,1)*2*se[i], function(x) max(x,0)), lw=2.4)
  }

}


```


```{r}
for_plotting=c('integer','double')
variables_to_plot_normally=summs_df$summary[summs_df$output%in%for_plotting]
print(variables_to_plot_normally)
df2=apply(df[,as.character(variables_to_plot_normally)],c(1,2),as.numeric)
all_plots(df2)

```

```{r}
all_nums(df2)
```


```{r}
for(variable in variables_to_plot_normally){
  if(variable %in% colnames(sim_df)){
    print(variable)
    print(hist_numbers(df2[,variable], sim_df[,variable], name=variable))
  }
}
```

```{r}
if('majority_tree' %in% colnames(df)){
  library(rwty)
  write.table(data.frame(majority_tree=df$majority_tree, emp=NA), file='tmp.phy', sep=';', quote=F, row.names= F, col.names =F, na='')
  write.table(df, file='tmp.log', quote=F, row.names=F, col.names = T)
  print(table(df$majority_tree))
  g=load.trees('tmp.phy', type = "newick", gens.per.tree = 1, logfile= 'tmp.log', skip=0)
  g=list(g)
  g[[1]]$ptable=g[[1]]$ptable[,as.character(variables_to_plot_normally)]
  #approx.ess=topological.approx.ess(g, burnin = 0)
  #print(approx.ess)
  at=analyze.rwty(g, fill.color='posterior')
  
}
```


Analysing each proposal type with respect to mhr.
```{r}
if('proposal_type' %in% colnames(df)){
  barplot(table(df$proposal_type))
  if( 'mhr' %in% colnames(df)){
    rmf=function(x,n=750){
      x=sapply(x, function(x){min(as.numeric(x),1)})
      return((cumsum(x)[(n+1):length(x)]-cumsum(x[1:(length(x)-n)]))/n)
    }
    rmeans= aggregate(mhr ~ proposal_type, df, rmf, simplify = T)
    df_rmeans=data.frame(do.call(cbind, rmeans[,2]))
    colnames(df_rmeans) <- rmeans[,1]
    df_rmeans$id=1:nrow(df_rmeans)
    library('ggplot2')
    library('reshape2')
    df_melt=melt(df_rmeans, id='id')
    ggplot(df_melt,aes(x=id,y=value,colour=variable,group=variable)) + geom_line()
  }
}
```
```{r}
x1=subset(df, proposal_type=='deladmix')$mhr
x2=subset(df, proposal_type=='addadmix')$mhr
y1=sapply(x1, function(x){min(as.numeric(x),1)})
y2=sapply(x2, function(x){min(as.numeric(x),1)})
c(mean(y1), mean(y2))
```

```{r}
df_deladmix=subset(df, proposal_type=='deladmix')
df_addadmix=subset(df, proposal_type=='addadmix')
df_rescale= subset(df, proposal_type=='rescale')
df_regraft= subset(df, proposal_type=='sliding_regraft')

list_of_dfs=list(df_deladmix, df_addadmix, df_regraft, df_rescale)

for(df_ in list_of_dfs){
  print(nrow(df_))
  print(summary(lm(mhr ~ likelihood_difference+ branch_prior_difference+ no_admix_prior_difference+adix_prop_prior_difference+top_prior_difference, data = df_)))
}


```

```{r}
lf=list.files('segments/')
full_files=paste0('segments/',lf)
plot(1, type='n', xlim=c(0,100000/10), ylim=c(0,1))
plot_file=function(filename){
  ad=scan(filename)
  iterations=ad[1:(length(ad)/2)]
  proportions=ad[(length(ad)/2+1):length(ad)]
  lines(iterations, proportions)
}
for(filename in full_files){
  plot_file(filename)
}
```

```{r}
admix_no_correction=as.numeric(as.character(df$rescale_admixtures_adap_param))
admix_correction=as.numeric(as.character(df$rescale_admix_correction_adap_param))
x_axis=1:2000
plot(x_axis[which(is.na(admix_no_correction)==0)], na.omit(admix_no_correction), type='l', ylim=c(0,0.2))
points(x_axis[which(is.na(admix_correction)==0)], na.omit(admix_correction), type='l', col='red')
```

